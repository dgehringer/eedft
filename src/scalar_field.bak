function ∇(f::ScalarField{T, V}) where {T, V}
    ∂x, ∂y, ∂z = (f.g_data .* 1.0im .* f.basis.G_shell_vectors[f.order][i,:] for i in 1:3)
    Vec3((ScalarField(f.basis, f.order, ∂α) for ∂α in (∂x, ∂y, ∂z))...)
end

function -(f::ScalarField{T, V}) where {T, V}
    ScalarField(f.basis, f.order, -f.g_data)
end

function add(f::ScalarField{T, V}, g::ScalarField{T, V}; op=+) where {T, V}
    f.order == g.order && return ScalarField(basis, f.order, op(f.g_data, g.g_data))
    s_up, s_down = ((f.order > g.order) ? (f, g) : (g, f))
    upscale_map = f.basis.G_shell_upscale_maps[s_down.order => s_up.order]
    g_data_up = copy(s_up.g_data)
    g_data_up[upscale_map] = op(g_data_up[upscale_map],  s_down.g_data)
    ScalarField(f.basis, max(f.order, g.order), g_data_up)
end

+(f::ScalarField{T, V}, g::ScalarField{T, V}) where {T, V} = add(f, g; op=+)
-(f::ScalarField{T, V}, g::ScalarField{T, V}) where {T, V} = add(f, g; op=-)

function add(f::Number, g::ScalarField{T, V}) where {T, V}
    g_data_new = copy(g.g_data)
    g_data_new[1] = T(f) + g_data_new[1]
    ScalarField(g.basis, g.order, g_data_new)
end

+(f::Number, g::ScalarField{T, V}) where {T, V} = add(f, g)
+(f::ScalarField{T, V}, g::Number) where {T, V} = add(g, f)

-(f::Number, g::ScalarField{T, V}) where {T, V} = add(f, -g)
-(f::ScalarField{T, V}, g::Number) where {T, V} = add(-g, f)

function Δ(f::ScalarField{T, V}) where {T, V} 
    ∂²x, ∂²y, ∂²z = (f.g_data .* (f.basis.G_shell_vectors[f.order][i,:] .^2) for i in 1:3)
    ScalarField(f.basis, f.order, ∂²x + ∂²y + ∂²z)
end

∇² = Δ

function *ᵣ(f::ScalarField{T, V}, g::ScalarField{T, V}) where {T, V}
    r_f = G_to_r(f)
    r_g = G_to_r(g)
    r_f .* r_g
end

function *(f::ScalarField{T, V}, g::ScalarField{T, V}) where {T, V}
    new_order = f.order + g.order
    new_order ∈ keys(f.basis.G_shell_indices_flat) || throw(DomainError(new_order, "Multiplication of scalarfields would lead to order $(new_order)"))

    ScalarField(f.basis, new_order, f *ᵣ g; is_real = true)
end

*(f::W, g::ScalarField{T, V}) where {T, V, W <: Number} = ScalarField(g.basis, g.order, T(f) * g.g_data)
*(f::ScalarField{T, V}, g::W) where {T, V, W <: Number} = g*f

function ⋅ᵣ(f::Vec3{ScalarField{T, V}}, g::Vec3{ScalarField{T, V}}) where {T, V}
   fᵢ, fⱼ, fₖ = f 
   gᵢ, gⱼ, gₖ = g 
   fᵢ *ᵣ gᵢ + fⱼ *ᵣ gⱼ + fₖ *ᵣ gₖ
end

function ⋅(f::Vec3{ScalarField{T, V}}, g::Vec3{ScalarField{T, V}}) where {T, V}
    for α in 1:3
        @assert f[α].order == f[1].order
        @assert g[α].order == g[1].order
    end
    new_order = f[1].order + g[1].order
    new_order ∈ keys(f[1].basis.G_shell_indices_flat) || throw(DomainError(new_order, "Multiplication of scalarfields would lead to order $(new_order)"))

    ScalarField(f[1].basis, new_order, f ⋅ᵣ g; is_real=true)
end

function density_real(f::ScalarField{T, V}) where {T, V}
    f_r = G_to_r(f)
    f_r .* Base.conj(f_r)
end

function density(f::ScalarField{T, V}) where {T, V}
    new_order = 2*f.order
    new_order ∈ keys(f.basis.G_shell_indices_flat) || throw(DomainError(new_order, "Multiplication of scalarfields would lead to order $(new_order)"))
    ScalarField(f.basis, new_order, density_real(f))
end

function inv(f::ScalarField{T, V}) where {T, V}
    f_inv_r = 1.0 ./ G_to_r(f)
    ScalarField(f.basis, f.order, f_inv_r; is_real=true)
end

function /(f::ScalarField{T, V}, g::ScalarField{T, V}) where {T, V}
    f_r = G_to_r(f)
    g_inv_r = 1.0 ./ G_to_r(g)
    ScalarField(f.basis, f.order, f_r .* g_inv_r; is_real=true)
end
